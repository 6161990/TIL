## :pushpin: JVM (Java Virtual Machine) 자바 가상 머신

### :round_pushpin: JVM 이란 무엇인가?
* ##### 자바 프로그램의 실행을 위해 물리적 환경과 유사하게 소프트웨어로 구현한 것이다. 
* ##### 바이너리 코드를 읽고 검증하고 실행하는 역할을 한다.
* ##### Java와 OS사이에서 중개자 역할을 수행하며 OS에 구애받지 않고 재사용을 가능하게 해준다. 
* ##### 또한, 메모리 관리 와 가비지 컬렉션을 수행한다. 

<br>
<br>

### :round_pushpin: JVM의 실행 

<img width="600" height="550" src="https://user-images.githubusercontent.com/74708028/139566142-00f65022-74cc-4924-9a52-15ef105287b6.jpg">


 * ##### JVM은 스택 기반으로 운영되는데 자바 쓰레드가 생성되면 그 쓰레드를 위한 JVM스택을 생성하는데 이를 Run-Time스택(Thread Stack)이라고 한다.
 * ##### JVM 스택은 메소드를 위한 각 메소드 마다 stack fram을 할당하는데 해당 스레드가 수행하는 모든 메서드호출은 매개변수, 로컬변수, 중간 계산산 및 기타 데이터를 포함하여 해당 메소드의 런타임 스택에 저장된다. 
 * ##### 새 메소드가 호출되면 JVM 스택의 맨 위에 stack frame이 생성되고 실행 제어가 호출되는 메소드로 넘어간다.
 * ##### 메소드 실행이 종료되면 JVM 스택에서 메소드의 런타임 스택 항목이 제거된다. 
 * ##### 그림에서 class의 b()메소드 실행이 끝나면 JVM스택에 있는 b stack frame도 제거된다.
 * ##### 결국 class의 main()가 종료되면 main thread도 종료될 때 그 안에 있던 JVM stack도  해제된다. 
 * ##### 최종적으로 쓰레드가 종료되기 직전에 JVM 스택은 해제된다는 얘기다. JVM 스택에 저장된 데이터는 해당 스레드에서 사용할 수 있으며, 나머지 스레드에서는 사용할 수 없다.
 * ##### 따라서 메소드 안에서 선언된 로컬 데이터는 스레드로부터 안전하다고 말할 수 있다. 
 
 * ##### 한편, 객체는 사용자의 new 연산자에 의해 메모리 힙에서 객체가 생성되고 JVM의 GC에 의해 자동으로 힙 메모리에서 해제된다. 


<br>
<br>

### :round_pushpin: 실행 환경 적인 면에서 다른 언어와의 차이점 (컴파일 되는 과정, 바이트 코드)

<img width="900" height="450" src="https://user-images.githubusercontent.com/74708028/139528715-8d3c7660-7d9d-4414-9f58-63d3952584d4.jpg">

 * ##### 플랫폼에 독립적인 프로그래밍을 할 수 있다? 는 무슨 말이야! 
 * ##### c 소스 코드를 실행하려할 때, 윈도우에서 실행하고 싶다면 윈도우 형 컴파일러에서 컴파일을 실행해야하고 
 * ##### 리눅스에서 실행하고 싶다면 그 파일을 그대로 가져가서 사용할 수 없고 리눅스 형 컴파일러에서 컴파일을 실행해야한다. 
 * ##### 그 이유는 c 언어가 두 개의 실행 파일 속 기계어의 상태가 환경에 따라 전혀 다르게 동작하기 때문이다.

<br>

 * ##### 반면, 자바의 경우는 '중간 기계어'라고도하는 바이트 코드의 상태의 .class 라는 파일이 컴파일에서 만들어진다. 
 * ##### 이 파일이 가상 머신만 있으면 어느 환경에서든 같은 결과를 만들어낸다. 
 * ##### 윈도우라면 윈도우 자바 가상머신이 .class 파일을 해석하고 리눅스라면 리눅스 자바 가상 머신이 .class 파일을 해석하여 실행한다.
 * ##### 즉, 바이트 코드는 특정 가상 머신 위에서 실행될 수 있는 클래스 파일이다. 
  
<br>
<br>

### :round_pushpin: 자바 프로그램 실행되는 과정


<img width="800" height="450" src="https://user-images.githubusercontent.com/74708028/139566814-807914f9-957d-44ff-b779-a0202104ec91.jpg">


 * ##### Class Loader에서 Test 클래스가 메모리에 적재된다(class 파일들을 JVM으로 로딩).
 * ##### 로딩된 class 파일들은 Execution engine을 통해 해석된다.
 * ##### 해석된 바이트코드는 Runtime Data Areas에 배치되어 실직적인 수행이 이루어지게 된다.

 * ##### 그림으로 이해해보자면, Test 클래스 내의 sum(), main()의 바이트코드가 JVM의 mathod area에 올라온다.
 * ##### 프로그램이 실행되면 JVM은 OS로 부터 이 프로그램이 필요로하는 메모리를 할당받는다.
 * ##### JVM 은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다. 
 * ##### 이러한 실행과정 속에서 JVM은 필요에 따라 Thread Synchronization 과 GC같은 관리 작업을 수행한다. 

<br>
<br>

### :round_pushpin: JIT 컴파일러란 무엇이며 어떻게 동작하는지

* ##### 자바 바이트코드(.class 파일)을 명령어 단위로 읽어서 네이티브 코드(기계어)로 번역하고 실행한다. 
* ##### 실행엔진은 자바 바이트 코드를 실제 OS에서 인식할 수 있는 기계어로 변환을 시도하는데 그 중 한가지 방법이 JIT 컴파일러다.
* ##### 바이트 코드의 유사한 부분을 동시에 컴파일하므로 컴파일에 필요한 로딩 시간이 죽어든다. 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 전체를 
* ##### 컴파일 하여 기계어로 번역한다. 이후에는 네이티브 코드를 직접 실행하며 실행된 네이티브 코드를 캐시에 보관하여 이미 컴파일된 코드라면 더 빠른 속도로 실행할 수 있게 한다.
* ##### 근데 JIT 컴파일러는 인터프리터 방식에 비해 속도가 느리므로, 단 한번만 실행되는 코드라면 인터프리터 방식이 훨씬 유리하다.
* ##### 그러므로 JIT 컴파일러를 사용하는 JVM은 내부적으로 해당 메소드가 자주 수행되는 정도를 체크하여 일정 정도를 넘을 때  JIT 컴파일러를 이용한다.
* ##### 특히, Hot Spot VM은 핫스팟 컴파일러라고 부르는 JIT컴파일러를 이용하는데, 핫스팟이라고 부르는 이유가 바로 내부적으로 가장 컴파일이 필요한 부분(핫 스팟)을 찾아 네이티브 코드로 번역하기 때문이다. 

<br>
<br>

### :round_pushpin: JVM 구성 요소

![JVM-Architecture](https://user-images.githubusercontent.com/74708028/139567319-274d61db-2929-4802-af09-4d4f31355b84.png)
* ##### Class Loader : 클래스 로더는 클래스를 로드할 때 이미 로드된 클래스인지 확인하기 위해 네임스페이스에 보관된 FQCN(Fully Qualified Class Name)을 기준(패키지이름, 클래스이름)으로 클래스를 찾고 FQCN이 같더라도 네임스페이스가 다르면 다른 클래스로 간주하여 로드한다. 즉 각각의 클래스 로더가 각자 네임 스페이스를 가지고 있기 때문에 패키지 명까지 같은 즉, FQCN이 같은 클래스라도 다른 클래스가 된다. 
      *  부트 스트랩 클래스 로더 : 자바 기본 API에 있는 클래스를 로드하여 다른 클래스 로더와 달리 자바가 아닌 네이티브 코드로 되어 있다. 
      *  시스템 클래스 로더 : 사용자가 지정한 CLASSPATH 경로의 클래스를 로드한다.
      *  클래스 로드에는 5단계가 있는데, 로드-> 검증(클래스가 자바 언어 스펙을 지켰는가)-> 준비(메모리할당, 기본값 초기화) -> 분석 -> 초기화(스태틱 변수초기화) 순이다. 
* ##### Runtime Data Area
* ##### Execution Engine 

<br>
<br>


### :round_pushpin: JDK와 JRE의 차이 자바
![image](https://user-images.githubusercontent.com/74708028/139568109-73f1d146-acea-4f98-a9b6-4b3ddd3c1958.png)


* ####  Java Runtime Environment : 자바로 짠 소프트웨어가 컴파일 및 빌드까지 다 된 다음 이를 사용할 곳에 주어져서 실행이 될 때!  그때 필요한 환경 요소.
   * ##### 컴파일 및 빌드까지 된거니까 당연히 JVM이 그 안에 내포되어 있다. 
   * ##### 그래서 stack, list 등 자바로 코딩할 때 필요한 라이브러리들이 안에 구현되어 들어있다.
   * ##### 그래서 자바로 작성한 프로그램을 돌리려면 이 JRE가 설치되어있어야 한다. 
   * ##### 마인크래프트가 자바로 만들어진 게임이라 게임 설치시 jre도 함께 설치되는 것을 알 수 있다.

* ####  Java Development Kit : JRE에 추가해서 개발에 필요한 것들이 키트로 꾸며진 것이다. 자바 코드를 컴파일할 때 쓰는 javac, 디버깅할 때 쓰이는 jdb, 서로 연고나있는 클래스들을 하나의 jar 파일로 묶어주는 jar

<br>
<br>


* 출처 : https://intexsoft.com/blog/tools-for-launching-and-developing-products-on-jvm/
