## :pushpin: JVM (Java Virtual Machine) 자바 가상 머신

#### :round_pushpin: JVM 이란 무엇인가?
##### 자바 프로그램의 실행을 위해 물리적 환경과 유사하게 소프트웨어로 구현한 것이다. 바이너리 코드를 읽고 검증하고 실행하는 역할을 한다.
##### Java와 애플리케이션을 클래스 로더로 통해 읽어 들여 자바 API와 함께 실행한다. 
##### Java와 OS사이에서 중개자 역할을 수행하며 OS에 구애받지 않고 재사용을 가능하게 해준다. 
##### 또한, 메모리 관리 와 가비지 컬렉션을 수행한다. 
##### JVM은 클래스 로더를 통해 자바 클래스를 메모리로 로드하여 자바 API를 이용하여 실행한다.
##### JVM은 스택 기반으로 운영되는데 자바 쓰레드가 생성되면 그 쓰레드를 위한 JVM스택을 생성하는데 이를 Run-Time스택이라고 한다.
##### JVM 스택은 메소드를 위한 각 메소드 마다 스택 프레임을 할당하는데 해당 스레드가 수행하는 모든 메서드호출은 매개변수, 로컬변수, 중간 꼐산 및 기타 데이터를 포함하여 해당 메소드의 런타임 스택에 저장된다. 
##### 메소드 실행이 종료되면 JVM 스택에서 메소드의 런타임 스택 항목이 제거된다. 
##### 최종적으로 쓰레드가 종료되기 직전에 JVM 스택은 해제된다. 결국 JVM 스택에 저장된 데이터는 해당 스레드에서 사용할 수 있으며, 나머지 스레드에서는 사용할 수 없다.
##### 따라서 메소드 안에서 선언된 로컬 데이터는 스레드로부터 안전하다고 말할 수 있다. 
##### 객체는 사용자의 new 연산자에 의해 메모리 힙에서 객체가 생성되고 JVM의 GC에 의해 자동으로 힙 메모리에서 해제된다. 

<br>
<br>

#### :round_pushpin: 실행 환경 적인 면에서 다른 언어와의 차이점 (컴파일 되는 과정, 바이트 코드)
##### 플랫폼에 독립적인 프로그래밍을 할 수 있다. 
##### c 소스 코드를 실행하려할 때, 윈도우에서 실행하고 싶다면 윈도우 형 컴파일러에서 컴파일을 실행해야하고 
##### 리눅스에서 실행하고 싶다면 그 파일을 그대로 가져가 사용할 수 없고 리눅스 형 컴파일러에서 컴파일을 실행해야한다. 
##### 그 이유는 c 언어가 두 개의 실행 파일 속 기계어의 상태가 환경에 따라 전혀 다르게 동작하기 때문이다.

<br>

##### 반면, 자바의 경우는 '중간 기계어'라고도하는 바이트 코드의 상태의 .class 라는 파일이 컴파일에서 만들어진다. 
##### 이 파일이 가상 머신만 있으면 어느 환경에서든 같은 결과를 만들어낸다. 
##### 윈도우라면 윈도우 자바 가상머신이 .class 파일을 해석하고 리눅스라면 리눅스 자바 가상 머신이 .class 파일을 해석하여 실행한다.
##### 즉, 바이트 코드는 특정 가상 머신 위에서 실행될 수 있는 클래스 파일이다. 
  
<br>
<br>

#### :round_pushpin: 자바 프로그램 실행되는 과정
##### 프로그램이 실행되면 JVM은 OS로 부터 이 프로그램이 필요로하는 메모리를 할당받는다.
##### JVM 은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다. 
##### 자바 컴파일러(javac) 자바 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환시킨다.
##### Class Loader를 통해 class 파일들을 JVM으로 로딩한다.
##### 로딩된 class 파일들은 Execution engine을 통해 해석된다.
##### 해석된 바이트코드는 Runtime Data Areas에 배치되어 실직적인 수행이 이루어지게 된다. 
##### 이러한 실행과정 속에서 JVM은 필요에 따라 Thread Synchronization 과 GC같은 관리 작업을 수행한다. 

<br>
<br>

#### :round_pushpin: JIT 컴파일러란 무엇이며 어떻게 동작하는지


<br>
<br>

#### :round_pushpin: JVM 구성 요소

<br>
<br>


#### :round_pushpin: JDK와 JRE의 차이 자바

<br>
<br>
